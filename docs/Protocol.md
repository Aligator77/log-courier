# Protocol

## Overview

This is a technical document intended for other developers who may wish to write
their own log shippers and use the courier Logstash gem to receive the events
rather than writing their own receiver.

The courier protocol is a message-based client-server protocol with asynchronous
capabilities. It is intended to be high throughput, reliable, and compatible
with common firewall implementations.

## Message Structure

```
+---+---+---+---+---+---+---+---+
| Type ID (4B)  | Length (4B)   |
+---+---+---+---+---+---+---+---+
| Data...
+
```

Every message starts with a 4 byte message type identifier, and is followed by
the length of the message and then the data.

All lengths and numbers are transmitted as 32-bit unsigned integers in Big
Endian format.

## Message Types

Messages identified as *Requests* MUST only be transmitted by a client that has
initiated a connection to a server.

Messages identified as *Responses* MUST only be transmitted by a server that has
accepted a connection from a client.

### PING

*Request*  
*Mandatory length of 0 and no data.*

A PING message SHOULD be sent after a period of inactivity on the connection.
Sending PING messages periodically ensures that stateful firewalls do not cause
the connection to be broken when the connection is needed again.

### PONG

*Response*  
*Mandatory length of 0 and no data.*

A PONG message MUST be sent after a PONG message has been received.

### JDAT

*Request*

A JSON payload of events, identified by a Nonce, compressed using the ZLIB
compression format. The length of the message MUST be the length of the
compressed data plus 16 bytes for the Nonce.

The Nonce SHOULD be 16-bytes of randomly generated bytes that uniquely
identifies this payload of events globally.

```
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| Nonce (16B)                                                   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| Compressed data...
+
```

Each event within the compressed data MUST be back-to-back and structured as
shown below, with a 4-byte length preceding the JSON object for the event.

```
+---+---+---+---+---+---+---+---+
| Length (4B)   | JSON data     ...
+---+---+---+---+---+---+---+---+
| Length (4B)   | JSON data     ...
+---+---+---+---+---+---+---+---+
| ...
+
```

Multiple JDAT messages CAN be transmitted consecutively without waiting for an
ACKN message response from the server.

If a server fails to decompress a JDAT message, it MUST disconnect the client
immediately.

### ACKN

*Response*

An acknowledgement for a payload of events, containing the Nonce that identifies
the payload globally and the number of events processed so far in that payload.
The length of the message MUST be 20 bytes.

```
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| Nonce (16B)                                                   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| Sequence No   |
+---+---+---+---+
```

If a client receives an ACKN message with a Nonce that does not correspond to
any payload of events the client submitted to the server on the same connection,
it MUST ignore the message.

If a client receives an ACKN message with a Nonce that identifies a payload of
events previously transmitted to the server on the same connection, but the
sequence number specified is out of range (i.e. higher than the number of events
transmitted,) it MUST process the ACKN message as if the sequence number was
exactly the number of events in the payload. Similarly, if the sequence number
is less than the sequence received in a previous ACKN message for the same
payload of events, it MUST be ignored.

If a client receives an ACKN message with a Nonce that identified a payload of
events that has not yet completed transmission, it MUST still process this
message asynchronously while the payload of events is still being transmitted.

### ????

Mandatory length of 0 and no data.

This message should be sent in response to a message that does not exist in the
protocol version the server or client connected implements. This is used to
allow for backwards compatibility in future versions of the protocol.
